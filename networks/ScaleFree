package networks;

import java.util.ArrayList;
import java.util.Random;

public class ScaleFree {

	public static void main(String[] args) {
		
		// generating the network
		Network startingNetwork = new Network();
		startingNetwork.addVertex();
		startingNetwork.addEdge(0, 1, 1, 1);
		build(startingNetwork, 30, 3); // initial network
		
		double[][] adjMatr = Network.generateAdjMatr(startingNetwork);
		double[][] weights = new double[adjMatr.length][adjMatr.length];
		Random generator = new Random();
		
		for (int i = 0; i < adjMatr.length; i++){
			for (int j = 0; j < adjMatr.length; j++){
				weights[i][j] = adjMatr[i][j] * Math.pow(0.1 + 0.3 * generator.nextDouble(), 2);
			}
		}
		
		
		// setting up P and Q
		ArrayList<double[]> pStar = new ArrayList<double[]>(); // prob. i is infected AT time t
		ArrayList<double[]> qStar = new ArrayList<double[]>(); // prob. i is infected BY time t

		
		double[] initialP = new double[adjMatr.length];
		for (int i = 0; i < adjMatr.length; i++){
			initialP[i] = 0.05 + 0.04 * generator.nextDouble(); // initial p
		}
		
		pStar.add(initialP);
		qStar.add(initialP);
		
		double[] nextP = new double[adjMatr.length];
		for (int i = 0; i < adjMatr.length; i++){
			double product = 1;
			for (int j = 0; j < adjMatr.length; j++){
				if (adjMatr[j][i] > 0){
					product *= (1 - weights[j][i] * pStar.get(0)[j]);
				}
			}
			nextP[i] = 1 - product;
		}
		
		pStar.add(nextP.clone());
		double[] nextQ = new double[adjMatr.length];
		for (int i = 0; i < adjMatr.length; i++){
			nextQ[i] = Math.min(1, qStar.get(0)[i] + pStar.get(1)[i]); // 1 - (1 - qStar.get(0)[i]) * (1 - pStar.get(1)[i]);
		}
		qStar.add(nextQ.clone());
		
		
		int timeLim = 100;
		for (int k = 2; k < timeLim; k++){
			
			for (int i = 0; i < adjMatr.length; i++){
				double product = 1;
				double sum = 0;
				for (int j = 0; j < adjMatr.length; j++){
					
					if (adjMatr[j][i] > 0){
						sum += qStar.get(k-2)[j] * weights[j][i];
					}
					
					if (adjMatr[j][i] > 0){
						product *= (1 - Math.min(pStar.get(k-1)[j] * weights[j][i] * (1 - qStar.get(k-2)[j]) / (1 - Math.min(sum, 1 - 0.00000001)), 1));
					}
					
				}
				nextP[i] = 1 - product;
			}
			pStar.add(nextP.clone());
			
			for (int i = 0; i < adjMatr.length; i++){
				nextQ[i] = Math.min(1, qStar.get(k-1)[i] + pStar.get(k)[i]); // 1 - (1 - qStar.get(k-1)[i]) * (1 - pStar.get(k)[i]);
			}
			qStar.add(nextQ.clone());
		}
		
		
		for (int k = 0; k < timeLim; k++){
			double[] marg = pStar.get(k);
			double[] temp = qStar.get(k);
			for (int i = 0; i < 1; i++){
				System.out.println(marg[i]);
				System.out.println(temp[i]);
			}
			System.out.println();
		}
		
		
	}
	
	
	
	
	public static void build(Network graph, int size, double connectivity){
		while (graph.size() < size){
			int i = graph.addVertex();
			for (Person p : graph.vertices){
				if (i != p.ID && binChoice(p.getFriends().size() * connectivity / graph.edges.size())){
					graph.addEdge(i, p.ID, 1, 1);
				}
			}
		}
	}
	
	public static boolean binChoice(double chance){
		Random generator = new Random();
		double out = generator.nextDouble();
		if (out < chance) return true;
		else return false;
	}


}
